<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>4교시: 게임 개발 고급 주제</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="./styles/lecture.css">
</head>
<body>

<div class="slider-container">

    <!-- SLIDE 1: Title & Overview -->
    <div class="slide active">
        <div class="col-left">
            <h2 style="color:#7ee787; font-size:1.2rem;">4교시</h2>
            <h1 class="main-title">게임 개발 고급 주제 개요</h1>
            <p style="margin-top:8px;">이번 세션은 게임 디자인(UX/재미), 적 AI(FSM), 자료구조/알고리즘(QuadTree, A*), 스케일업 아키텍처, 그리고 온라인 멀티플레이 핵심 개념을 다룹니다.</p>
            <div style="background:#161b22;padding:16px;border-radius:8px;border:1px solid #30363d;margin-top:12px;color:#c9d1d9;">
                <ul style="list-style:none;padding-left:6px;line-height:1.6;">
                    <li>게임 디자인: UX, 재미 요소, 중독성 루프</li>
                    <li>적 AI: 상태 머신(FSM) 예시</li>
                    <li>공간 파티셔닝(QuadTree), 경로탐색(A*)</li>
                    <li>스케일업/엔진 고도화(엔티티 시스템, 이벤트 버스)</li>
                    <li>온라인 멀티플레이: Client–Server, 동기화, 예측/보간</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- SLIDE 2: Game Design (UX, Fun Loop) -->
    <div class="slide">
        <h1 class="main-title">게임 디자인 요소</h1>
        <div class="col-left">
            <h2 class="slide-title">UX와 재미 요소</h2>
            <p>플레이어 경험을 설계할 때 고려할 핵심 요소들:</p>
            <ul style="margin-top:8px;line-height:1.6;">
                <li><strong>학습-숙련 루프</strong>: 쉬운 진입, 점진적 난이도 설계(튜토리얼 → 챌린지)</li>
                <li><strong>즉각적 피드백</strong>: 입력에 대한 가시적/청각적 반응(히트 이펙트, 소리)</li>
                <li><strong>목표·보상 설계</strong>: 단기 보상(점수, 파워업) + 장기 목표(업적, 스토리)</li>
                <li><strong>중독성 루프 설계</strong>: 작은 성공 경험을 반복해서 제공하는 구조(퀘스트, 리워드 타이밍)</li>
            </ul>
            <h3 style="margin-top:12px;">실무 팁</h3>
            <ol style="line-height:1.6;">
                <li>핵심 루프 1개를 먼저 만들고 반복적으로 개선하세요.</li>
                <li>데이터로 검증: retention(1d,7d), ARPU, 세션 길이 추적.</li>
                <li>피드백을 빠르게 적용할 수 있는 프로토타이핑을 유지하세요.</li>
            </ol>
        </div>
    </div>

    <!-- SLIDE 3: Enemy AI (FSM) -->
    <div class="slide">
        <h1 class="main-title">적 AI: 간단한 상태 머신(FSM)</h1>
        <div class="grid-2">
            <div class="col-left">
                <h2 class="slide-title">FSM 구성 요소</h2>
                <ul style="line-height:1.6;">
                    <li>상태(State): Patrol, Chase, Attack, Flee 등</li>
                    <li>전이(Transition): 조건에 따라 상태 변경</li>
                    <li>행동(Action): 상태에 따른 행동 실행</li>
                </ul>
            </div>
            <div class="col-right">
                <div class="code-block">
<pre><code>extends Node2D

enum State { PATROL, CHASE, ATTACK }
var state = State.PATROL

func _process(_delta):
	match state:
		State.PATROL:
			patrol()
			if can_see_player():
				state = State.CHASE
		State.CHASE:
			chase()
			if in_attack_range():
				state = State.ATTACK
		State.ATTACK:
			attack()
			if lost_player():
				state = State.PATROL
</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- SLIDE 4: Data Structures & Algorithms in Games -->
    <div class="slide">
        <h1 class="main-title">자료구조/알고리즘의 실무적 활용</h1>
        <div class="col-left">
            <p>게임에서 자주 쓰이는 자료구조와 그 응용:</p>
            <ul style="line-height:1.6;">
                <li><strong>QuadTree</strong>: 많은 엔티티에 대한 근접 검색/충돌 검사 최적화에 사용</li>
                <li><strong>A* 경로탐색</strong>: 네비게이션 그리드 또는 네비게이션 메쉬에서 최적 경로 계산</li>
                <li><strong>해시맵</strong>: 아이템/엔티티 조회, 컴포넌트 매핑</li>
                <li><strong>우선순위 큐(힙)</strong>: 스케줄링, 이벤트 처리, A*의 오픈 리스트</li>
            </ul>
            <h3 style="margin-top:12px;">적용 예시</h3>
            <p style="line-height:1.6;">- 충돌 검사: 전체 쌍 검사 대신 QuadTree로 영역 쿼리 → 주변 객체만 검사.<br>- 경로탐색: 휴리스틱을 조정해 성능/품질 균형 조정(Manhattan vs Euclidean).</p>
        </div>
    </div>

    <!-- SLIDE 5: Spatial Partitioning (QuadTree) -->
    <div class="slide">
        <h1 class="main-title">공간 파티셔닝: QuadTree</h1>
        <div class="col-left">
            <h2 class="slide-title">왜 필요한가?</h2>
            <p>많은 오브젝트에 대해 모든 쌍의 충돌을 검사하면 O(n^2)이 됩니다. QuadTree는 영역을 분할해 관심 영역(nearby) 쿼리를 빠르게 합니다.</p>
            <h3 style="margin-top:10px;">간단한 작동 원리</h3>
            <ol style="line-height:1.6;">
                <li>루트 노드가 영역을 가진다.</li>
                <li>엔티티가 많아지면 영역을 4등분하여 서브노드로 분할(subdivide).</li>
                <li>쿼리 시 해당 영역에 해당하는 노드들만 탐색해 빠르게 후보를 얻는다.</li>
            </ol>
            <h3 style="margin-top:10px;">주의점</h3>
            <ul style="line-height:1.6;">
                <li>동적 객체가 많을 때는 업데이트 비용(삽입/삭제)이 발생합니다.</li>
                <li>엔티티가 영역 경계에 있는 경우 복수 노드에 등록해야 할 수도 있습니다.</li>
            </ul>
        </div>
    </div>

    <!-- SLIDE 6: Pathfinding (A*) -->
    <div class="slide">
        <h1 class="main-title">경로 탐색: A* (A-star)</h1>
        <div class="grid-2">
            <div class="col-left">
                <p>A*는 휴리스틱(heuristic)을 사용해 최적 경로를 찾는 알고리즘입니다. 실시간 게임에서는 해상도/그리드, 휴리스틱(Manhattan/Euclidean)을 조정해야 합니다.</p>
            </div>
            <div class="col-right">
                <div class="code-block">
<pre><code># A* 간단한 의사코드
open_set = PriorityQueue()
open_set.push(start, 0)
came_from = {}
g_score[start] = 0
while not open_set.empty():
	current = open_set.pop()
	if current == goal: return reconstruct_path(came_from, current)
	for neighbor in neighbors(current):
		tentative_g = g_score[current] + cost(current, neighbor)
		if tentative_g < g_score.get(neighbor, inf):
			came_from[neighbor] = current
			g_score[neighbor] = tentative_g
			f = tentative_g + heuristic(neighbor, goal)
			open_set.push(neighbor, f)
</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- SLIDE 7: Scaled Game Architecture & Advanced Patterns -->
    <div class="slide">
        <h1 class="main-title">스케일업된 게임 구조</h1>
        <div class="col-left">
            <p>규모가 커질수록 코드와 데이터의 구조화가 중요합니다. 작은 팀/프로젝트와 대형 프로젝트의 요구사항은 다릅니다.</p>
            <ul style="line-height:1.6;">
                <li><strong>엔티티-컴포넌트(ECS)</strong>: 컴포넌트로 기능을 분리해 캐시 친화적이고 확장 가능하게 설계</li>
                <li><strong>이벤트 버스 / 메시지 큐</strong>: 서브시스템 간 느슨한 결합을 제공, 테스트/확장 용이</li>
                <li><strong>서브시스템 분리</strong>: 렌더링, 물리, 입력, 네트워크 등 책임 분리</li>
            </ul>
            <h3 style="margin-top:10px;">실무 예시</h3>
            <p style="line-height:1.6;">- 네트워크는 별도 스레드/프로세스로 격리해 I/O 지연 영향 최소화<br>- 콘텐츠 파이프라인을 명확히 해 아티스트/디자이너가 빠르게 작업 가능하게 함</p>
        </div>
    </div>

    <!-- SLIDE 8: Dev Pipeline -->
    <div class="slide">
        <h1 class="main-title">실제 게임 개발 파이프라인</h1>
        <div class="col-left">
            <ol style="line-height:1.6;">
                <li>기획 → 프로토타입: 핵심 가설(핵심 루프)을 빠르게 검증</li>
                <li>콘텐츠 제작(아트, 사운드, 레벨): 파이프라인 자동화가 생산성 핵심</li>
                <li>QA → 출시 → 운영: 원격 로깅/모니터링으로 빠른 대응
                    <ul>
                        <li>크래시/오류 리포트, 플레이 텔레메트리, 세션 분석</li>
                    </ul>
                </li>
            </ol>
            <h3 style="margin-top:10px;">프로세스 팁</h3>
            <ul style="line-height:1.6;">
                <li>작은 배포 단위를 유지해 리스크 감소</li>
                <li>자동화된 테스트(유닛/통합)과 수동 QA의 균형 유지</li>
            </ul>
        </div>
    </div>

    <!-- SLIDE 9: Multiplayer basics (expanded) -->
    <div class="slide">
        <h1 class="main-title">멀티플레이 핵심 개념</h1>
        <div class="col-left">
            <h2 class="slide-title">동기화 모델: 스냅샷 vs 요청-응답(서버 권한)</h2>
            <p style="line-height:1.6;">
                온라인 게임은 크게 두 가지 상호작용 모델을 혼합해서 사용합니다. 실시간 움직임/상태는 <strong>스냅샷 기반 동기화</strong>과 클라이언트 예측으로 부드럽게 보이는 반면,
                중요한 게임 규칙 변경(구매, 스킬 발동의 결과, 트랜잭션)은 <strong>서버에 요청을 보내고 서버 반응에 따라 동작하는 요청-응답</strong> 방식으로 처리합니다.
            </p>

            <h3 style="margin-top:10px;">스냅샷 기반(주로 실시간 게임)</h3>
            <ul style="line-height:1.6;">
                <li>서버가 정기적으로 게임 상태(스냅샷)를 브로드캐스트 → 클라이언트는 보간(interpolation)으로 부드럽게 표시.</li>
                <li>클라이언트 예측(client-side prediction): 입력을 로컬로 적용해 지연을 숨기고, 서버 스냅샷 수신시 리컨실리이션(재동기화)을 수행.</li>
                <li>장점: 반응성 우수(이동/조작이 즉시 느껴짐). 단점: 복원·동기화 로직 필요, 충돌/분쟁 가능성.</li>
            </ul>

            <h3 style="margin-top:10px;">요청-응답 / 서버 권한(주로 보정·권한형 기능)</h3>
            <ul style="line-height:1.6;">
                <li>클라이언트가 액션을 서버에 전송(RPC/command) → 서버가 검증하고 결과(성공/실패, 생성된 엔티티 등)를 응답.</li>
                <li>사용처: 금전 거래, 아이템 획득/상점, 스킬의 최종 판정, 게임 룰 위반 방지 등</li>
                <li>장점: 보안/일관성 확보(서버가 최종 권한). 단점: 네트워크 왕복(latency)으로 즉시성 저하 — 보상으로는 확실한 규칙 적용.</li>
            </ul>

            <h3 style="margin-top:10px;">혼합 전략과 실무 패턴</h3>
            <ul style="line-height:1.6;">
                <li>실시간 이동은 스냅샷+예측, 상호작용 결과는 요청-응답으로 처리(예: 공격 명중 판정은 서버에서 최종 확정).</li>
                <li>낙관적 실행(optimistic actions): 클라이언트가 먼저 UI/애니메이션을 재생하고, 서버 응답으로 확정/되돌리기(reconcile) 처리.</li>
                <li>롤백/롤포워드(rollback/rollforward): 파이팅 게임 등에서는 입력을 기록하고, 서버 시뮬레이션 차이를 보정하기 위해 롤백 전략을 사용.</li>
                <li>명령 기반(command-based) 모델: 클라이언트가 'command'를 보내고 서버는 그 순서를 결정해 실행 → 결정적 시뮬레이션과 결합하면 락스텝(lockstep) 스타일에 가깝게 동작.</li>
            </ul>

            <h3 style="margin-top:10px;">운영/성능 고려사항</h3>
            <ul style="line-height:1.6;">
                <li>스냅샷 빈도와 델타 압축: 네트워크 사용량 대비 실시간성 균형을 맞춰야 함.</li>
                <li>관심 관리(interest management): 클라이언트에 필요한 부분만 전송하여 대역폭 절약.</li>
                <li>시퀀스 번호·타임스탬프: 패킷 순서와 재전송 처리, 재동기화에 필수.</li>
                <li>보안/검증: 서버는 항상 클라이언트 입력을 검증하고 치팅을 차단해야 함.</li>
            </ul>

            <h3 style="margin-top:10px;">언제 어떤 모델을 선택하나?</h3>
            <ul style="line-height:1.6;">
                <li>빠른 반응이 중요한 실시간 액션(플레이어 이동, 조준): 스냅샷 + 예측/보간</li>
                <li>엄격한 규칙·트랜잭션(거래, 중요한 판정): 요청-응답(서버 권한)</li>
                <li>격투/레트로 FPS 같은 타이밍에 극도로 민감한 장르는 롤백 넷코드 고려</li>
            </ul>

            <h3 style="margin-top:10px;">디버깅 & 테스트 팁</h3>
            <ul style="line-height:1.6;">
                <li>의도적으로 패킷 지연/손실을 넣어 리컨실리이션/예측 동작을 검증하세요.</li>
                <li>서버 로그에 클라이언트 명령 및 최종 판정 기록을 남겨 불일치 원인을 추적합니다.</li>
                <li>네트워크 스냅샷 샘플링과 세션 텔레메트리를 수집해 플레이 품질을 모니터링하세요.</li>
            </ul>
        </div>
    </div>

    <!-- SLIDE 10: Q&A (minimal) -->
    <div class="slide">
        <div style="display:flex;align-items:center;justify-content:center;height:66vh;">
            <h1 style="font-size:4rem;margin:0;color:#c9d1d9;">Q&amp;A</h1>
        </div>
    </div>

    <!-- NAVIGATION -->
    <div class="nav-bar">
        <div class="page-indicator">Page <span id="current-page">1</span> / 10</div>
        <div class="nav-buttons">
            <button class="nav-btn" id="prev-btn" onclick="changeSlide(-1)" disabled>
                <i class="fa-solid fa-chevron-left"></i> 이전
            </button>
            <button class="nav-btn" id="next-btn" onclick="changeSlide(1)">
                다음 <i class="fa-solid fa-chevron-right"></i>
            </button>
        </div>
    </div>

</div>

<script>
    let currentSlideIndex = 0;
    const slides = document.querySelectorAll('.slide');
    const totalSlides = slides.length;
    const pageIndicator = document.getElementById('current-page');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');

    function changeSlide(direction) {
        slides[currentSlideIndex].classList.remove('active');
        currentSlideIndex += direction;
        if (currentSlideIndex < 0) currentSlideIndex = 0;
        if (currentSlideIndex >= totalSlides) currentSlideIndex = totalSlides - 1;
        slides[currentSlideIndex].classList.add('active');
        pageIndicator.innerText = currentSlideIndex + 1;
        prevBtn.disabled = (currentSlideIndex === 0);
        nextBtn.disabled = (currentSlideIndex === totalSlides - 1);
    }
</script>

</body>
</html>
